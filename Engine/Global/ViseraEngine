#pragma once
// << Layers >>
namespace VE
{
    class Visera;
    /*1*/   class ViseraCore;
    /*2*/   class ViseraInternal;
    /*3*/   class ViseraRuntime;
    /*3.1*/     class PlatformRuntime;
    /*3.2*/     class RenderRuntime;

}
#define VISERA_RUNTIME

// << STD Modules >>
#include <cassert>
#include <sstream>
#include <ostream>
#include <fstream>
#include <iostream>
#include <format>
#include <chrono>
#include <algorithm>
#include <thread>
#include <ranges>
#include <memory>
#include <functional>
#include <source_location>
#include <exception>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <type_traits>

// << Global Macros >>

//Asserts
namespace VE
{
    inline void Assert(bool expression, const char* prompt = "") { assert(expression && prompt); }

    constexpr bool False   = false;
    constexpr bool True    = !False;

    /* <<  Concepts >>
       
    */
   
    template <typename T>
    concept Hashable = requires(T type) {{ std::hash<T>{}(type) } -> std::same_as<std::size_t>;};

    template<typename T>
    concept UnsignedIntegerol = std::unsigned_integral<T>;

    template<typename T>
    concept SignedInteger = std::integral<T>;

    template<typename T>
    concept Integer = std::integral<T> || std::unsigned_integral<T>;

    template<typename T>
    concept FloatingPoint = std::floating_point<T>;

    template<typename T>
    concept Number = std::floating_point<T> || std::integral<T>;

    /* <<  Basic Types >>
       
    */
    using Bool		= bool;
    using Float  	= float;
    using Double 	= double;
    using Int32  	= std::int32_t;
    using UInt32 	= std::uint32_t;
    using Int64  	= std::int64_t;
    using UInt64 	= std::uint64_t;

    using String	 = std::string;
    using StringView = std::string_view;
    using RawString  = const char*;

    using Byte		= unsigned char;
    using EnumMask	= std::uint32_t;
    using EnumBit	= std::uint32_t;
    template<typename T> inline
    UInt64 BytesOf() { return sizeof(T); }
    template<typename T> inline
    UInt64 BitsOf()  { return 8 * BytesOf<T>(); }

    using ID		= std::uint32_t;
    using Token		= std::uint64_t;
    using Address   = void*;
    using ErrorCode = std::int32_t;

    /* <<  Containers >>
        1. Array
        2. Set
        3. HashMap
    */

    template<typename T>
    using Array	   = std::vector<T>;

    template<typename T>
    using Set	   = std::unordered_set<T>;

    template<Hashable Key, typename Value>
    using HashMap  = std::unordered_map<Key, Value>;

    /* <<  Pointers >>
        1. SharedPtr
        2. WeakPtr
        3. UniquePtr
    */

    template<typename T>
    using SharedPtr   = std::shared_ptr<T>;
    template<typename T, typename... Args>
    inline SharedPtr<T>
    CreateSharedPtr(Args &&...args) { return std::make_shared<T>(std::forward<Args>(args)...); }

    template<typename T>
    using WeakPtr	  = std::weak_ptr<T>;

    template<typename T>
    using UniquePtr   = std::unique_ptr<T>;
    template<typename T, typename... Args>
    inline UniquePtr<T> 
    CreateUniquePtr(Args &&...args) { return std::make_unique<T>(std::forward<Args>(args)...); }
}

namespace VISERA_APP_NAMESPACE
{
    inline void Assert(bool expression, const char* prompt = "") { assert(expression && prompt); }

    constexpr bool False   = false;
    constexpr bool True    = !False;

    /* <<  Basic Types >>
       
    */
    using Bool		= VE::Bool;
    using Float  	= VE::Float;
    using Double 	= VE::Double;
    using Int32  	= VE::Int32;
    using UInt32 	= VE::UInt32;
    using Int64  	= VE::Int64;
    using UInt64 	= VE::UInt64;

    using String	 = VE::String;
    using StringView = VE::StringView;
    using RawString  = VE::RawString;

    using Byte		= VE::Byte;
    using EnumMask	= VE::EnumMask;
    using EnumBit	= VE::EnumBit;
    template<typename T> inline
    UInt64 BytesOf() { return sizeof(T); }
    template<typename T> inline
    UInt64 BitsOf()  { return 8 * BytesOf<T>(); }

    /* <<  Containers >>
        1. Array
        2. Set
        3. HashMap
    */

    template<typename T>
    using Array	   = VE::Array<T>;

    template<typename T>
    using Set	   = VE::Set<T>;

    template<VE::Hashable Key, typename Value>
    using HashMap  = VE::HashMap<Key, Value>;

    /* <<  Pointers >>
        1. SharedPtr
        2. WeakPtr
        3. UniquePtr
    */

    template<typename T>
    using SharedPtr   = VE::SharedPtr<T>;
    template<typename T, typename... Args>
    inline SharedPtr<T>
    CreateSharedPtr(Args &&...args) { return VE::CreateSharedPtr<T>(std::forward<Args>(args)...); }

    template<typename T>
    using WeakPtr	  = VE::WeakPtr<T>;

    template<typename T>
    using UniquePtr   = VE::UniquePtr<T>;
    template<typename T, typename... Args>
    inline UniquePtr<T> 
    CreateUniquePtr(Args &&...args) { return VE::CreateUniquePtr<T>(std::forward<Args>(args)...); }
}