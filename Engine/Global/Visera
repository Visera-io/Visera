#pragma once
// << Layers >>
#define VISERA_RUNTIME

// << STD Modules >>
#include <cassert>
#include <sstream>
#include <ostream>
#include <fstream>
#include <iostream>
#include <format>
#include <chrono>
#include <algorithm>
#include <thread>
#include <ranges>
#include <memory>
#include <functional>
#include <source_location>
#include <exception>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <type_traits>

// << Global Macros >>

//Asserts
namespace VE
{
    inline void Assert(bool expression, const char* prompt = "") { assert(expression && prompt); }

    /* <<  Concepts >>
       
    */
    template <typename T>
    concept Hashable = requires(T type) {{ std::hash<T>{}(type) } -> std::same_as<std::size_t>;};

    template<typename T>
    concept UnsignedIntegerol = std::unsigned_integral<T>;

    template<typename T>
    concept SignedInteger = std::integral<T>;

    template<typename T>
    concept Integer = std::integral<T> || std::unsigned_integral<T>;

    template<typename T>
    concept FloatingPoint = std::floating_point<T>;

    template<typename T>
    concept Number = std::floating_point<T> || std::integral<T>;

    template<typename T>
    concept ClockType = std::is_class_v<std::chrono::system_clock>          ||
                        std::is_class_v<std::chrono::high_resolution_clock>;

    /* <<  Basic Types >>
       
    */
    using Bool		= bool;
    using Float  	= float;
    using Double 	= double;
    using Int32  	= std::int32_t;
    using UInt32 	= std::uint32_t;
    using Int64  	= std::int64_t;
    using UInt64 	= std::uint64_t;

    using String	 = std::string;
    using StringView = std::string_view;
    using RawString  = const char*;

    using Byte		= unsigned char;
    using EnumMask	= std::uint32_t;
    using EnumBit	= std::uint32_t;
    template<typename T> inline
    UInt64 BytesOf() { return sizeof(T); }
    template<typename T> inline
    UInt64 BitsOf()  { return 8 * BytesOf<T>(); }

    using ID		= std::uint32_t;
    using Token		= std::uint64_t;
    using Address   = void*;
    using ErrorCode = std::int32_t;

    constexpr Bool False   = false;
    constexpr Bool True    = !False;

    /* <<  Containers >>
        1. Array
        2. Set
        3. HashMap
    */

    template<typename T>
    using Array	   = std::vector<T>;

    template<typename T>
    using Set	   = std::unordered_set<T>;

    template<Hashable Key, typename Value>
    using HashMap  = std::unordered_map<Key, Value>;

    /* <<  Pointers >>
        1. SharedPtr
        2. WeakPtr
        3. UniquePtr
    */

    template<typename T>
    using SharedPtr   = std::shared_ptr<T>;
    template<typename T, typename... Args>
    inline SharedPtr<T>
    CreateSharedPtr(Args &&...args) { return std::make_shared<T>(std::forward<Args>(args)...); }

    template<typename T>
    using WeakPtr	  = std::weak_ptr<T>;

    template<typename T>
    using UniquePtr   = std::unique_ptr<T>;
    template<typename T, typename... Args>
    inline UniquePtr<T> 
    CreateUniquePtr(Args &&...args) { return std::make_unique<T>(std::forward<Args>(args)...); }
}